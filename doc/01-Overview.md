# 项目概述

本项目旨在构建一个针对Fortran语言的高性能解析与语义建模框架，其核心使命是将大规模、复杂的Fortran代码库转换为可索引、可查询、可追溯的知识图谱（Knowledge Graph）实例层。与传统编译器侧重于生成机器码的目标不同，本项目的核心价值在于对代码及其语义进行结构化提取与持久化存储，建立“代码即数据”的分析基础设施。具体目标包含以下两个维度：

- 解决高性能计算（HPC）与工程代码的极端复杂度问题。框架设计必须原生支持大规模工程实践中的复杂场景，具体包括：处理由预处理器（CPP）主导的多重条件编译变体；解析跨文件、跨模块甚至跨子模块（Submodule）的复杂作用域可见性传播；精确建模Fortran强类型系统，涵盖派生类型（Derived Types）与参数化派生类型（PDT）；以及承载百万行级代码量的语句索引与表达式树构建，为后续的数据流分析与调用图提取奠定坚实基础。

- 实现从源码到语义图谱的精确映射。系统将以代码中的真实元素为核心实体，建立包括作用域（Scopes）、类型规范（Type Specs）、命名实体（Entities）、控制流语句（Statements）及计算表达式（Expressions）在内的全要素节点，并精确构建它们之间的结构化关联（如包含、继承）与语义关联（如引用、调用、类型绑定）。

本系统不采取传统编译器前端紧耦合的单体设计，转而采用一系列正交的、可组合的数据转换管道（Data Transformation Pipelines）。整个架构是一组离散的、纯函数式的分析能力集合，上层应用可根据需求灵活编排这些能力，构建从基础语法分析到深度语义索引的完整工作流。

采用分层递进的流水线模型。系统将解析过程解构为若干个独立定义的处理阶段（Passes），包括预处理视图构建、作用域拓扑分析、类型系统建模、符号实体注册、控制流索引、表达式树构建以及名称绑定与语义消歧（Resolve）。每个阶段仅关注特定维度的信息提取，通过定义清晰的输入/输出契约（Contracts）进行串联，从而隔离了关注点，例如将控制流分析（语句层）与数据流细节（表达式层）物理分离，并将复杂的全局消歧（名称绑定、过程解析、类型绑定）集中封装到独立的Resolve阶段，从而降低了单个模块的复杂度。严格遵循不可变产物与确定性原则。每个处理子系统均被设计为数学意义上的纯函数，即 Output = Function(Input, Configuratio


# 子系统划分

## cpptree：预处理结构与源码视图建模子系统

建立源代码的物理视图与变体视图，将Fortran源代码文件解析为包含预处理指令的结构化树（Preprocessed Tree），解决条件编译带来的代码多义性问题。 

- 解析并保留C预处理器指令（CPP Directives）及其嵌套结构，包括宏定义（#define）、条件包含（#ifdef/ifndef/else/endif）以及文件包含（#include）。 

- 构建条件编译区域（Conditional Regions）的拓扑结构，将源代码划分为受宏控制的独立文本块，允许上层应用根据不同的宏定义配置（Configuration）提取出特定的代码变体。 

- 输出不可变的源码视图产物，该产物作为字符串，能够按需还原为合法的Fortran字符流，作为后续语法解析的输入基底。

## fscopinggraph：作用域拓扑与可见性管理子系统

构建程序的静态作用域骨架，确立“名称”的查找路径与可见性规则，通过图结构描述程序中的空间层级与模块间的依赖关系。 

- 识别并构建所有的作用域单元（Scoping Units），涵盖Program、Module、Submodule、Subroutine、Function、Block Construct以及Interface Body等层次化结构。

- 建立作用域之间的层级关系（Parent-Child），处理Host Association（宿主关联），确立内部过程对宿主变量的访问权限。 解析模块间的引用关系，

- 处理Use Association（使用关联）和Submodule Ancestry，构建跨文件的可见性传播边，并处理Import指令带来的名字空间穿透。 

- 在作用域拓扑与可见性规则已确立的前提下，提取并确定Parameter常量的字面值映射表（Parameter Map）。

- 输出一张包含所有潜在查找路径的作用域图（Scope Graph），为后续的符号查找与名称绑定提供确定的导航地图。

## ftypspec：类型定义与类型系统建模子系统

提取并管理程序中定义的所有数据类型蓝图，解决类型依赖关系，构建类型及其组件的元数据描述，关注类型的结构定义，而非类型的具体变量实例。

- 解析并存储所有Intrinsic Type（内置类型）的参数化规格（如Kind、Len）。 解析Derived Type（派生类型）的定义结构，包括其成员组件（Components）、组件的初始化表达式以及类型绑定的过程（Type-bound Procedures）。 

- 处理Parameterized Derived Types (PDT) 的模板定义，管理Kind和Len类型参数的约束。 

- 基于fscopinggraph输出的Parameter Map解决类型定义中的常量依赖问题（如类型Kind/Len值依赖于某个Parameter常量）。

- 输出类型图（Type Graph），包含全部唯一的类型规范（TypeSpec）。

## fsymtab：实体注册与符号属性管理子系统

在已知的作用域与类型基础上，识别代码中的声明语句，注册具体的实体（Entities），并绑定其语义属性，是将“名称”映射为“具象实体”的关键环节。

- 扫描所有声明部分（Specification Part），在对应的作用域中注册实体，区分变量、常量、形参、过程名、接口块名等不同类别的符号。

- 解析并绑定实体的所有静态属性，包括类型属性（引用ftypspec的产物）、存储属性（Allocatable, Pointer, Target, Save）、访问控制属性（Public, Private）以及过程意图属性（Intent）。

- 处理隐式类型规则（Implicit Rules），为未显式声明的符号自动推导并注册符合Fortran标准的类型属性。

- 输出完整的符号表（Symbol Table），该表将作用域中的字符串名称锚定为具有丰富语义信息的实体对象，作为后续语义分析的基础数据库。

## fstmts：执行流与语句索引子系统

解析程序执行部分（Execution Part）的控制流骨架，将连续的字符流转换为离散的、有序的语句对象序列，不深入解析语句内部的表达式细节。

- 识别并切分所有可执行语句（Executable Statements），如Assignment、If-Then-Else、Do/While Loops、Call、Select Case、IO语句等。

- 维护语句在源代码中的物理顺序与逻辑嵌套关系，构建基本的控制流图（CFG）前驱结构，识别Label与GoTo跳转目标。

- 为每个语句分配全局唯一的稳定ID，作为后续数据流分析与表达式挂载的锚点。

- 输出语句流，提供按作用域查询语句序列的能力，支持对程序控制逻辑的快速遍历。

## fexprs：表达式树与操作数建模子系统

填充语句内部的计算逻辑，将语句的操作数槽位解析为细粒度的表达式树，并建立语句与表达式之间的引用关系。

- 解析语句中的右值表达式、左值引用、函数调用参数、数组索引、逻辑判断条件等，将其转化为结构化的Expr节点树。

- 对表达式中的原子操作数进行分类，包括字面量（Literals）、操作符（Operators）以及名称引用（Name References）。

## fresolve：名称绑定与语义消歧子系统

在作用域图谱、类型图谱与符号表已完备的基础上，对表达式与语句中遗留的延迟引用进行全局一致的绑定与消歧，输出可直接用于调用图、类型绑定与数据流分析的语义边集合。

- 解析并消歧所有SymbolRef名称引用，沿Scope Graph确定候选实体集合，并在可判定条件下绑定到相应实体。

- 对过程调用进行解析与绑定，处理Interface/Generic分派与模块过程可见性，建立CallSite到目标过程实体的精确关联。

- 将类型引用、派生类型组件引用以及类型绑定过程（Type-bound Procedures）的引用关系统一落库，建立“引用—定义”与“调用—被调用”的语义关联边，使语义图谱实例层具备闭合的可推理结构。

- 输出Resolve产物，包括已绑定引用表（Resolved Reference Table）、歧义/失败诊断表（Resolution Diagnostics）以及增量可复用的消歧缓存键（Resolution Cache Keys），为后续高阶分析提供稳定的语义基座。