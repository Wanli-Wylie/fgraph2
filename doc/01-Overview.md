# 项目概述

本项目面向大规模 Fortran 工程代码，构建一套以持久化索引为核心的“代码即数据”基础设施。系统的产出不是一次性的编译产物，而是一组可长期存续、可增量演进、可跨工具复用的结构化索引，使源码能够以数据的形态被查询、被追踪、被组合，并作为后续语言服务与科学计算分析的统一底座。

架构范式从“单体编译器前端”转向“分布式查询/语言服务引擎”。传统前端倾向于在一次流水线中把语法、作用域、类型、消歧与绑定强耦合地折叠成闭合语义图谱；本项目则将能力拆解为若干正交子系统，每个子系统只负责一个语义维度的稳定索引构建，形成多个可独立演进的拓扑骨架与声明性事实集合。上层以查询的方式组合这些索引，在需要时才进行语义推断与链接，从而获得更强的解耦性、语义内聚与可组合性。

全局采用“索引—计算分离”模式。存储层仅固化物理结构与基础声明，包括预处理后的纯净代码流、全局编排坐标系、类型与接口的本体论定义、实体声明的注册表、控制流骨架以及表达式树的结构化表示。所有高成本且上下文敏感的语义推断，例如重载决议、泛型分派、类型推导、参数化派生类型实例化、过程调用目标选择与跨单元可见性折叠，均由上层 Compute APIs 以惰性求值的方式按需实时计算。计算层的结果可以被缓存以服务交互式体验，但缓存不被视为权威落盘语义，不构成系统的唯一真相。

因此，系统不再保留将“最终语义图谱”落盘的 fresolve 子系统。语义闭包不被作为固定产物固化在数据库中，而是通过 API 动态链接不同索引，在查询时生成面向任务的语义视图。这一转变避免了全量消歧图谱在配置变化、宏变体变化与增量修改下的高失效成本，使系统能以更低的维护代价支持百万行级代码库的持续演进与多场景复用。

贯穿各子系统的工程原则是符号锚定与可追溯性。所有索引记录都以稳定标识与源码区间为锚点，并以明确的输入输出契约隔离关注点：索引构建阶段追求确定性、可重放与局部可更新；语义推断阶段追求按需、可组合与可分布式扩展。两者通过严格的边界与只读查询协作，形成既可工程化落地又能承载复杂语言语义的计算基础设施。

# 子系统划分

## cpptree：预处理视图与纯净代码流

Input 边界为原始源码文本、包含路径与宏配置等预处理上下文。该子系统负责处理宏展开、条件编译分支与包含关系，构建可回放的预处理视图，使上层能够在不同配置下获得一致的、可追溯的代码变体。

Output 边界为纯净的 Fortran 代码流及其变体结构描述，核心输出应同时携带从预处理视图回溯到原始文件与行列位置的映射信息，以保证后续索引产物具备稳定的符号锚定能力。

核心职责是将由预处理器引入的多义性收敛为结构化的变体空间，并为后续所有解析与索引阶段提供语法上自洽的输入流。cpptree 不承担任何 Fortran 语义推断，仅提供“可解析”的文本形态与可追溯的变体拓扑。

## fstructure：全局代码坐标系

Input 边界为 cpptree 的纯净代码流以及基本的文件边界与编译单元切分信息。该子系统的职责降级为提供全局坐标系，构建最小但稳定的导航骨架。

Output 边界为两类结构索引。其一是 Program、Module、Subprograms 等的物理嵌套树，即 Contains Tree，用于描述语句物理单元的空间归属与结构位置。其二是模块引用网络，即 Uses 关系，用于描述跨编译单元的依赖拓扑，但不展开为可见性闭包。

核心职责是把源代码组织成可定位、可分区、可索引的全局骨架，为后续子系统提供一致的“坐标系”与分片依据。fstructure 不涉及任何具体的符号查找逻辑，不计算 Host Association、Use Association 的可见性传播，不产出候选集合与解析路径，仅固化物理结构事实与引用边的声明性记录。

## foop：面向对象与类型系统

Input 边界为 cpptree 的纯净代码流以及 fstructure 提供的全局坐标系，用于为类型与接口定义提供稳定的归属与定位。foop 是全新引入的核心子系统，集中封装 Fortran 的 OOP 特性与高阶类型系统。

Output 边界为类型与接口的定义性索引，涵盖派生类型、参数化派生类型、类型继承关系、类型组件声明、类型绑定过程声明，以及各类接口定义，包括泛型接口、抽象接口与运算符重载接口。输出以“定义”为中心，形成程序的本体论结构，使类型与多态行为的规则源头具备语义内聚。

核心职责是固化类型系统的声明性事实与结构约束，并为计算层提供可查询的类型与接口元数据。foop 不负责将类型定义与具体实体实例强制链接，不执行调用点的重载决议与动态分派，不计算参数化派生类型的具体实例集合；这些上下文敏感且成本高昂的推断应由 Compute APIs 在查询时按需完成。

## fcallable：调用体索引

Input 边界为 cpptree 的纯净代码流与 fstructure 的全局坐标系，同时以只读方式查询 foop 与 fsymtab，用于识别可调用体的声明形态与界面签名。该子系统聚焦于 Fortran 中“可被调用”的一切语义载体，包括外部过程、模块过程、内部过程、接口体、类型绑定过程与过程指针目标的声明面。

Output 边界为可调用体注册表与调用界面模型。注册表负责为每个 callable 提供稳定标识、源码锚点与归属坐标；界面模型负责固化其签名拓扑，包括形参槽位、intent/optional/keyword 约束、返回值通道、pass/nopass 语义、以及与 generic/interface/operator 的结构性隶属关系。该输出只固化“调用契约”的结构事实，不尝试决定具体调用点将分派到哪个重载目标，也不计算跨作用域的可见性闭包。

核心职责是把“调用”从语句与表达式的局部结构中提炼为可查询的全局接口索引，为计算层提供统一的候选空间与诊断锚点。fcallable 本身不执行重载决议与动态分派，仅提供语义内聚的 callable 目录与接口形状，使上层 Compute APIs 能在不同查询上下文下以惰性求值完成最终的调用绑定与歧义诊断。

## fsymtab：实体注册系统

Input 边界为 cpptree 的纯净代码流与 fstructure 的全局坐标系。fsymtab 专注于“实例”的注册，在确定的坐标系下扫描各编译单元及其内部声明区域，将变量、常量、形参、命名常量与其他可声明实体登记为可索引对象。

Output 边界为实体注册表及其属性快照，核心输出是从名字到实体标识的登记关系，以及与源码锚点绑定的声明位置、属性集合与原始类型描述。该子系统采用惰性类型绑定策略，实体仅记录原始 Type Spec 字符串及其字面属性，不强行链接到 foop 中的类型定义，也不尝试构造参数化派生类型的具体实例。

核心职责是以低成本、确定性方式完成符号锚定与属性归档，使系统在不依赖全局语义闭包的前提下具备“可查询的声明事实”。fsymtab 不进行名称引用的绑定与消歧，不执行类型推导与类型实例化，不对泛型与重载建立调用级别的选择关系；这些都被刻意推迟到计算层，以保证索引层的稳定性与正交性。

## fstmts：控制流索引与语句拓扑骨架

Input 边界为 cpptree 的纯净代码流以及 fstructure 的定位信息。fstmts 扫描执行区域，将语句抽象为带操作数槽位的算子模型，形成控制流的基本拓扑骨架。

Output 边界为语句索引与控制流骨架描述，包括语句序列、结构化嵌套关系、跳转与合流的拓扑边，以及每条语句的槽位模式，用于后续表达式树挂载与数据流分析的入口对齐。输出必须提供稳定语句标识与源码锚点，使语句成为跨子系统可引用的结构化锚点。

核心职责是以结构化方式固化“执行的形状”，而不是解释“执行的含义”。fstmts 不解析槽位内部表达式，不解析调用目标，不构建数据依赖与定义使用链，不尝试推导分支条件的语义，保持控制流层与表达式层的物理分离，以维持拓扑骨架的简洁与可复用。

## fexprs：表达式树与结构化消歧

Input 边界为 fstmts 提供的语句槽位定位，以及 cpptree 的纯净代码流。构建过程中允许对 fsymtab 与 foop 进行只读查询，用于完成结构化消歧所必需的最小信息获取。

Output 边界为可持久化的表达式树索引，表达式节点与边以源码锚点与语句槽位锚点双重绑定，同时输出消歧标记与浅层回填结果，使表达式在结构层面可被稳定遍历与重写。该子系统的消歧目标严格限定为语法二义性消除，例如区分名称后随括号的形式是数组访问还是函数调用，或在结构构造与组件引用之间做结构性区分。

核心职责是以浅层回填策略构建表达式的结构表示，并通过结构化消歧保证树形拓扑的确定性。fexprs 不进行具体语义绑定，不选择重载候选中的唯一目标，不决定泛型接口的分派结果，不推导表达式类型与常量折叠；表达式中与名称、类型、过程相关的深层语义链接由 Compute APIs 在查询时动态生成。

## Compute APIs：按需语义计算与动态链接层

Input 边界为上述各索引子系统的持久化产物，计算层以只读方式消费这些索引，并可结合编译配置、宏变体、目标平台约束与查询上下文提供语义视图。Compute APIs 是索引层之上的计算平面，也是系统从编译器前端走向分布式查询/语言服务引擎的关键承载。

Output 边界为面向任务的派生语义视图，例如名称解析与引用绑定结果、重载与泛型分派决议、类型推导与参数化派生类型实例化、类型绑定过程的选择路径、调用层次与跨单元可见性折叠后的查询结果。输出可以被缓存以提升交互性能，但缓存属于可再生的派生物，不替代索引层的权威事实库。

核心职责是以惰性求值方式把“存储的结构事实”提升为“可用的语义答案”，并以动态链接替代一次性落盘的语义闭包。Compute APIs 需要显式暴露可组合的计算原语，使上层能够按需拼装语言服务与分析工作流，同时保持索引层的稳定、简洁与可验证，从而在复杂语义与工程可维护性之间取得可扩展的平衡。